# Vulnerability Scanning Workshop

## Objective
Master vulnerability scanning techniques, understand different scanning tools, and learn to analyze and prioritize findings effectively.

## Prerequisites
- Network security fundamentals
- Understanding of common vulnerabilities
- Basic scripting knowledge
- Lab environment setup

## Lab Overview
In this workshop, you will:
1. Configure and use various vulnerability scanners
2. Perform authenticated and unauthenticated scans
3. Analyze and validate scan results
4. Create custom vulnerability checks
5. Develop remediation strategies

## Part 1: Introduction to Vulnerability Scanning

### Exercise 1.1: Types of Vulnerability Scanners
```
1. Network Vulnerability Scanners
   - Nessus, OpenVAS, Qualys
   - Scan network services and configurations

2. Web Application Scanners
   - Burp Suite, OWASP ZAP, Acunetix
   - Focus on web-specific vulnerabilities

3. Database Scanners
   - SQLMap, DBProtect
   - Database-specific vulnerabilities

4. Container/Cloud Scanners
   - Trivy, Clair, AWS Inspector
   - Container and cloud infrastructure
```

### Exercise 1.2: Scanning Methodology
```python
#!/usr/bin/env python3
# Vulnerability scanning workflow

class VulnerabilityScanner:
    def __init__(self, target):
        self.target = target
        self.vulnerabilities = []
        
    def pre_scan_checks(self):
        """Pre-scanning validation"""
        checks = {
            'authorization': self.check_authorization(),
            'network_connectivity': self.check_connectivity(),
            'scan_window': self.check_scan_window(),
            'backup_status': self.check_backups()
        }
        return all(checks.values())
    
    def scan_phases(self):
        """Define scanning phases"""
        phases = [
            "Discovery Scan",
            "Port Scan",
            "Service Detection",
            "Vulnerability Detection",
            "Compliance Check"
        ]
        return phases
    
    def post_scan_analysis(self):
        """Analyze and prioritize findings"""
        # CVSS scoring
        # False positive analysis
        # Risk contextualization
        pass
```

## Part 2: OpenVAS/GVM Configuration

### Exercise 2.1: Installing and Configuring OpenVAS
```bash
# Install OpenVAS/GVM
sudo apt update
sudo apt install gvm

# Initial setup
sudo gvm-setup

# Check installation
sudo gvm-check-setup

# Start services
sudo gvm-start

# Create admin user
sudo runuser -u _gvm -- gvmd --create-user=admin --password=admin

# Access web interface
# https://localhost:9392
```

### Exercise 2.2: Creating Scan Configurations
```python
#!/usr/bin/env python3
# OpenVAS automation script

from gvm.connections import UnixSocketConnection
from gvm.protocols.gmp import Gmp
from gvm.transforms import EtreeTransform

def create_scan_config():
    connection = UnixSocketConnection()
    transform = EtreeTransform()
    
    with Gmp(connection, transform=transform) as gmp:
        # Authenticate
        gmp.authenticate('admin', 'password')
        
        # Create target
        target = gmp.create_target(
            name='Web Server Scan',
            hosts=['192.168.1.100', '192.168.1.101'],
            port_list_id='33d0cd82-57c6-11e1-8ed1-406186ea4fc5'
        )
        
        # Create scan task
        task = gmp.create_task(
            name='Weekly Vulnerability Scan',
            config_id='daba56c8-73ec-11df-a475-002264764cea',  # Full and fast
            target_id=target.get('id'),
            scanner_id='08b69003-5fc2-4037-a479-93b440211c73'
        )
        
        # Start scan
        gmp.start_task(task.get('id'))
        
        return task.get('id')

# Schedule regular scans
def schedule_scan():
    import schedule
    import time
    
    schedule.every().monday.at("02:00").do(create_scan_config)
    
    while True:
        schedule.run_pending()
        time.sleep(60)
```

## Part 3: Nessus Professional

### Exercise 3.1: Nessus Configuration
```bash
# Install Nessus (requires license)
# Download from tenable.com

# Start Nessus
sudo systemctl start nessusd

# Access web interface
# https://localhost:8834

# Configure scan policies
# 1. Basic Network Scan
# 2. Advanced Scan
# 3. Compliance Scan
# 4. Web Application Scan
```

### Exercise 3.2: Custom Nessus Audit Files
```xml
<!-- Custom compliance check -->
<custom_item>
  <type>CMD_EXEC</type>
  <description>Check SSH Protocol Version</description>
  <cmd>grep "^Protocol" /etc/ssh/sshd_config</cmd>
  <expect>Protocol 2</expect>
  <severity>HIGH</severity>
  <solution>Set Protocol 2 in sshd_config</solution>
</custom_item>

<!-- Windows registry check -->
<custom_item>
  <type>REG_CHECK</type>
  <description>Check Windows Update Settings</description>
  <value_type>POLICY_DWORD</value_type>
  <reg_key>HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate\AU</reg_key>
  <reg_item>NoAutoUpdate</reg_item>
  <value_data>0</value_data>
  <check_type>CHECK_EQUAL</check_type>
</custom_item>
```

## Part 4: Web Application Scanning

### Exercise 4.1: OWASP ZAP Configuration
```python
#!/usr/bin/env python3
# ZAP API automation

from zapv2 import ZAPv2
import time

class WebAppScanner:
    def __init__(self, target_url):
        self.zap = ZAPv2(apikey='your-api-key')
        self.target = target_url
    
    def spider_scan(self):
        """Spider the target application"""
        print(f'Spidering {self.target}')
        scan_id = self.zap.spider.scan(self.target)
        
        # Wait for spider to complete
        while int(self.zap.spider.status(scan_id)) < 100:
            print(f'Spider progress: {self.zap.spider.status(scan_id)}%')
            time.sleep(5)
        
        return self.zap.spider.results(scan_id)
    
    def active_scan(self):
        """Run active vulnerability scan"""
        print(f'Active scanning {self.target}')
        scan_id = self.zap.ascan.scan(self.target)
        
        # Monitor scan progress
        while int(self.zap.ascan.status(scan_id)) < 100:
            print(f'Scan progress: {self.zap.ascan.status(scan_id)}%')
            time.sleep(5)
        
        return self.zap.core.alerts()
    
    def generate_report(self, alerts):
        """Generate HTML report"""
        report = "<html><body><h1>Vulnerability Report</h1>"
        
        for alert in alerts:
            report += f"""
            <div>
                <h2>{alert['name']}</h2>
                <p>Risk: {alert['risk']}</p>
                <p>Confidence: {alert['confidence']}</p>
                <p>Description: {alert['description']}</p>
                <p>Solution: {alert['solution']}</p>
                <p>URL: {alert['url']}</p>
            </div>
            """
        
        report += "</body></html>"
        
        with open('zap_report.html', 'w') as f:
            f.write(report)

# Usage
scanner = WebAppScanner('http://testphp.vulnweb.com')
scanner.spider_scan()
alerts = scanner.active_scan()
scanner.generate_report(alerts)
```

### Exercise 4.2: Burp Suite Scanning
```python
# Burp Suite Enterprise API integration
import requests
import json

class BurpScanner:
    def __init__(self, api_key, base_url):
        self.api_key = api_key
        self.base_url = base_url
        self.headers = {
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json'
        }
    
    def create_scan(self, site_id, scan_config_id):
        """Create a new scan"""
        endpoint = f"{self.base_url}/api/v1/scans"
        
        data = {
            'site_id': site_id,
            'scan_configuration_id': scan_config_id
        }
        
        response = requests.post(
            endpoint,
            headers=self.headers,
            json=data
        )
        
        return response.json()['scan_id']
    
    def get_scan_status(self, scan_id):
        """Check scan status"""
        endpoint = f"{self.base_url}/api/v1/scans/{scan_id}"
        
        response = requests.get(
            endpoint,
            headers=self.headers
        )
        
        return response.json()['status']
    
    def get_vulnerabilities(self, scan_id):
        """Retrieve scan findings"""
        endpoint = f"{self.base_url}/api/v1/scans/{scan_id}/issues"
        
        response = requests.get(
            endpoint,
            headers=self.headers
        )
        
        return response.json()['issues']
```

## Part 5: Custom Vulnerability Checks

### Exercise 5.1: Network Service Scanner
```python
#!/usr/bin/env python3
# Custom vulnerability scanner for specific services

import socket
import ssl
import subprocess
from datetime import datetime

class ServiceVulnScanner:
    def __init__(self, target):
        self.target = target
        self.results = []
    
    def check_ssl_vulnerabilities(self, port=443):
        """Check for SSL/TLS vulnerabilities"""
        context = ssl.create_default_context()
        
        try:
            with socket.create_connection((self.target, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=self.target) as ssock:
                    # Check protocol version
                    protocol = ssock.version()
                    if protocol in ['TLSv1', 'TLSv1.1', 'SSLv2', 'SSLv3']:
                        self.results.append({
                            'vulnerability': 'Weak SSL/TLS Protocol',
                            'severity': 'HIGH',
                            'details': f'Server supports {protocol}',
                            'remediation': 'Disable TLSv1.1 and below'
                        })
                    
                    # Check cipher suites
                    cipher = ssock.cipher()
                    if 'RC4' in cipher[0] or 'DES' in cipher[0]:
                        self.results.append({
                            'vulnerability': 'Weak Cipher Suite',
                            'severity': 'MEDIUM',
                            'details': f'Using cipher: {cipher[0]}',
                            'remediation': 'Disable weak ciphers'
                        })
                    
                    # Check certificate
                    cert = ssock.getpeercert()
                    not_after = datetime.strptime(
                        cert['notAfter'],
                        '%b %d %H:%M:%S %Y %Z'
                    )
                    
                    if not_after < datetime.now():
                        self.results.append({
                            'vulnerability': 'Expired Certificate',
                            'severity': 'HIGH',
                            'details': f'Certificate expired on {not_after}',
                            'remediation': 'Renew SSL certificate'
                        })
                        
        except Exception as e:
            self.results.append({
                'vulnerability': 'SSL/TLS Connection Error',
                'severity': 'INFO',
                'details': str(e),
                'remediation': 'Investigate SSL/TLS configuration'
            })
    
    def check_ssh_vulnerabilities(self, port=22):
        """Check SSH configuration"""
        try:
            # Get SSH banner
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((self.target, port))
            banner = sock.recv(1024).decode().strip()
            sock.close()
            
            # Check version
            if 'SSH-1' in banner:
                self.results.append({
                    'vulnerability': 'SSH Protocol 1 Enabled',
                    'severity': 'HIGH',
                    'details': f'Banner: {banner}',
                    'remediation': 'Disable SSH protocol 1'
                })
            
            # Check for old versions
            if 'OpenSSH_5' in banner or 'OpenSSH_6' in banner:
                self.results.append({
                    'vulnerability': 'Outdated SSH Version',
                    'severity': 'MEDIUM',
                    'details': f'Banner: {banner}',
                    'remediation': 'Update SSH to latest version'
                })
                
        except Exception as e:
            pass
    
    def check_http_headers(self, port=80):
        """Check HTTP security headers"""
        import requests
        
        try:
            response = requests.get(
                f"http://{self.target}:{port}",
                timeout=5
            )
            headers = response.headers
            
            # Check security headers
            security_headers = {
                'X-Frame-Options': 'Clickjacking Protection',
                'X-Content-Type-Options': 'MIME Sniffing Protection',
                'Strict-Transport-Security': 'HTTPS Enforcement',
                'Content-Security-Policy': 'XSS Protection',
                'X-XSS-Protection': 'XSS Filter'
            }
            
            for header, description in security_headers.items():
                if header not in headers:
                    self.results.append({
                        'vulnerability': f'Missing {description}',
                        'severity': 'MEDIUM',
                        'details': f'Header {header} not found',
                        'remediation': f'Add {header} header'
                    })
            
            # Check for information disclosure
            if 'Server' in headers:
                self.results.append({
                    'vulnerability': 'Server Version Disclosure',
                    'severity': 'LOW',
                    'details': f'Server: {headers["Server"]}',
                    'remediation': 'Remove Server header'
                })
                
        except Exception as e:
            pass
    
    def generate_report(self):
        """Generate vulnerability report"""
        print(f"\nVulnerability Scan Report for {self.target}")
        print("=" * 60)
        print(f"Scan Date: {datetime.now()}")
        print(f"Total Findings: {len(self.results)}")
        print("\nFindings:")
        print("-" * 60)
        
        for finding in sorted(self.results, key=lambda x: x['severity']):
            print(f"\n[{finding['severity']}] {finding['vulnerability']}")
            print(f"Details: {finding['details']}")
            print(f"Remediation: {finding['remediation']}")

# Usage
scanner = ServiceVulnScanner('192.168.1.100')
scanner.check_ssl_vulnerabilities()
scanner.check_ssh_vulnerabilities()
scanner.check_http_headers()
scanner.generate_report()
```

### Exercise 5.2: Configuration Compliance Scanner
```python
#!/usr/bin/env python3
# Check system configurations against security baselines

import os
import subprocess
import json

class ComplianceScanner:
    def __init__(self):
        self.findings = []
        self.score = 100
    
    def check_linux_hardening(self):
        """Check Linux security configurations"""
        checks = [
            {
                'name': 'Password Policy',
                'command': 'grep -E "^PASS_MAX_DAYS|^PASS_MIN_DAYS|^PASS_MIN_LEN" /etc/login.defs',
                'expected': ['PASS_MAX_DAYS 90', 'PASS_MIN_DAYS 7', 'PASS_MIN_LEN 8'],
                'weight': 5
            },
            {
                'name': 'SSH Root Login',
                'command': 'grep "^PermitRootLogin" /etc/ssh/sshd_config',
                'expected': ['PermitRootLogin no'],
                'weight': 10
            },
            {
                'name': 'Firewall Status',
                'command': 'systemctl is-active ufw',
                'expected': ['active'],
                'weight': 10
            },
            {
                'name': 'Automatic Updates',
                'command': 'grep -E "^APT::Periodic::Update-Package-Lists|^APT::Periodic::Unattended-Upgrade" /etc/apt/apt.conf.d/20auto-upgrades',
                'expected': ['APT::Periodic::Update-Package-Lists "1"', 'APT::Periodic::Unattended-Upgrade "1"'],
                'weight': 5
            }
        ]
        
        for check in checks:
            try:
                result = subprocess.run(
                    check['command'],
                    shell=True,
                    capture_output=True,
                    text=True
                )
                
                passed = all(exp in result.stdout for exp in check['expected'])
                
                if not passed:
                    self.score -= check['weight']
                    self.findings.append({
                        'check': check['name'],
                        'status': 'FAILED',
                        'expected': check['expected'],
                        'found': result.stdout.strip()
                    })
                else:
                    self.findings.append({
                        'check': check['name'],
                        'status': 'PASSED'
                    })
                    
            except Exception as e:
                self.findings.append({
                    'check': check['name'],
                    'status': 'ERROR',
                    'error': str(e)
                })
    
    def check_docker_security(self):
        """Check Docker security configurations"""
        docker_checks = [
            {
                'name': 'Docker Daemon Configuration',
                'file': '/etc/docker/daemon.json',
                'required_settings': {
                    'icc': False,
                    'log-driver': 'json-file',
                    'log-opts': {'max-size': '10m', 'max-file': '3'}
                }
            }
        ]
        
        for check in docker_checks:
            try:
                with open(check['file'], 'r') as f:
                    config = json.load(f)
                
                for key, value in check['required_settings'].items():
                    if key not in config or config[key] != value:
                        self.findings.append({
                            'check': f"Docker {key}",
                            'status': 'FAILED',
                            'expected': value,
                            'found': config.get(key, 'Not configured')
                        })
                        
            except FileNotFoundError:
                self.findings.append({
                    'check': check['name'],
                    'status': 'FAILED',
                    'error': 'Configuration file not found'
                })
    
    def generate_compliance_report(self):
        """Generate compliance report"""
        print("\nSecurity Compliance Report")
        print("=" * 60)
        print(f"Compliance Score: {self.score}/100")
        print("\nDetailed Findings:")
        print("-" * 60)
        
        for finding in self.findings:
            status_symbol = "✓" if finding['status'] == 'PASSED' else "✗"
            print(f"\n{status_symbol} {finding['check']}: {finding['status']}")
            
            if finding['status'] == 'FAILED':
                if 'expected' in finding:
                    print(f"  Expected: {finding['expected']}")
                    print(f"  Found: {finding.get('found', 'N/A')}")
                if 'error' in finding:
                    print(f"  Error: {finding['error']}")

# Usage
scanner = ComplianceScanner()
scanner.check_linux_hardening()
scanner.check_docker_security()
scanner.generate_compliance_report()
```

## Part 6: Vulnerability Management

### Exercise 6.1: Vulnerability Database
```python
#!/usr/bin/env python3
# Vulnerability management system

import sqlite3
from datetime import datetime
import hashlib

class VulnerabilityDB:
    def __init__(self, db_path='vulnerabilities.db'):
        self.conn = sqlite3.connect(db_path)
        self.create_tables()
    
    def create_tables(self):
        """Create database schema"""
        self.conn.executescript('''
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                vuln_id TEXT UNIQUE,
                title TEXT,
                severity TEXT,
                cvss_score REAL,
                description TEXT,
                solution TEXT,
                discovered_date TEXT,
                status TEXT DEFAULT 'open'
            );
            
            CREATE TABLE IF NOT EXISTS assets (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                hostname TEXT,
                ip_address TEXT,
                os TEXT,
                criticality TEXT
            );
            
            CREATE TABLE IF NOT EXISTS vuln_instances (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                vuln_id TEXT,
                asset_id INTEGER,
                port INTEGER,
                service TEXT,
                evidence TEXT,
                discovered_date TEXT,
                remediated_date TEXT,
                status TEXT DEFAULT 'open',
                FOREIGN KEY (vuln_id) REFERENCES vulnerabilities(vuln_id),
                FOREIGN KEY (asset_id) REFERENCES assets(id)
            );
        ''')
        self.conn.commit()
    
    def add_vulnerability(self, vuln_data):
        """Add vulnerability to database"""
        vuln_id = hashlib.md5(
            f"{vuln_data['title']}{vuln_data['severity']}".encode()
        ).hexdigest()[:10]
        
        try:
            self.conn.execute('''
                INSERT INTO vulnerabilities 
                (vuln_id, title, severity, cvss_score, description, solution, discovered_date)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (
                vuln_id,
                vuln_data['title'],
                vuln_data['severity'],
                vuln_data.get('cvss_score', 0),
                vuln_data['description'],
                vuln_data['solution'],
                datetime.now().isoformat()
            ))
            self.conn.commit()
            return vuln_id
        except sqlite3.IntegrityError:
            # Vulnerability already exists
            return vuln_id
    
    def track_remediation(self, vuln_id, asset_id):
        """Mark vulnerability as remediated"""
        self.conn.execute('''
            UPDATE vuln_instances 
            SET status = 'remediated', 
                remediated_date = ?
            WHERE vuln_id = ? AND asset_id = ? AND status = 'open'
        ''', (datetime.now().isoformat(), vuln_id, asset_id))
        self.conn.commit()
    
    def get_metrics(self):
        """Get vulnerability metrics"""
        metrics = {}
        
        # Total vulnerabilities by severity
        cursor = self.conn.execute('''
            SELECT severity, COUNT(*) 
            FROM vuln_instances 
            WHERE status = 'open'
            GROUP BY severity
        ''')
        
        metrics['by_severity'] = dict(cursor.fetchall())
        
        # Average remediation time
        cursor = self.conn.execute('''
            SELECT AVG(julianday(remediated_date) - julianday(discovered_date))
            FROM vuln_instances
            WHERE status = 'remediated'
        ''')
        
        metrics['avg_remediation_days'] = cursor.fetchone()[0] or 0
        
        return metrics

# Usage
db = VulnerabilityDB()
vuln_id = db.add_vulnerability({
    'title': 'Outdated Apache Version',
    'severity': 'HIGH',
    'cvss_score': 7.5,
    'description': 'Apache version 2.4.41 has known vulnerabilities',
    'solution': 'Update to Apache 2.4.54 or later'
})
```

### Exercise 6.2: Automated Remediation
```python
#!/usr/bin/env python3
# Automated vulnerability remediation

import subprocess
import logging

class AutoRemediation:
    def __init__(self):
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
    
    def remediate_vulnerability(self, vuln_type, details):
        """Dispatch to appropriate remediation function"""
        remediation_map = {
            'missing_updates': self.install_updates,
            'weak_ssh_config': self.harden_ssh,
            'missing_firewall_rule': self.add_firewall_rule,
            'weak_password_policy': self.update_password_policy
        }
        
        if vuln_type in remediation_map:
            return remediation_map[vuln_type](details)
        else:
            self.logger.warning(f"No automated remediation for {vuln_type}")
            return False
    
    def install_updates(self, details):
        """Install security updates"""
        try:
            # Update package list
            subprocess.run(['sudo', 'apt', 'update'], check=True)
            
            # Install security updates
            subprocess.run([
                'sudo', 'apt', 'upgrade', '-y',
                '--only-upgrade', details.get('package', '')
            ], check=True)
            
            self.logger.info(f"Successfully updated {details.get('package')}")
            return True
            
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to install updates: {e}")
            return False
    
    def harden_ssh(self, details):
        """Harden SSH configuration"""
        ssh_config = '/etc/ssh/sshd_config'
        
        hardening_settings = {
            'PermitRootLogin': 'no',
            'PasswordAuthentication': 'no',
            'X11Forwarding': 'no',
            'Protocol': '2',
            'MaxAuthTries': '3',
            'ClientAliveInterval': '300',
            'ClientAliveCountMax': '2'
        }
        
        try:
            # Backup original config
            subprocess.run([
                'sudo', 'cp', ssh_config, f'{ssh_config}.backup'
            ], check=True)
            
            # Apply hardening settings
            for setting, value in hardening_settings.items():
                subprocess.run([
                    'sudo', 'sed', '-i',
                    f's/^#*{setting}.*/{setting} {value}/g',
                    ssh_config
                ], check=True)
            
            # Restart SSH service
            subprocess.run([
                'sudo', 'systemctl', 'restart', 'sshd'
            ], check=True)
            
            self.logger.info("SSH configuration hardened successfully")
            return True
            
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to harden SSH: {e}")
            return False

# Usage
remediator = AutoRemediation()
remediator.remediate_vulnerability('weak_ssh_config', {})
```

## Lab Challenges

### Challenge 1: Comprehensive Scan
Perform a complete vulnerability assessment:
1. Network vulnerability scan
2. Web application scan
3. Configuration compliance check
4. Container security scan
5. Generate consolidated report

### Challenge 2: Custom Scanner Development
Build a custom scanner that:
1. Detects specific misconfigurations
2. Integrates with multiple scanning tools
3. Provides risk scoring
4. Suggests remediation steps

### Challenge 3: Vulnerability Management System
Create a system that:
1. Aggregates results from multiple scanners
2. Tracks vulnerability lifecycle
3. Automates remediation where possible
4. Provides metrics and dashboards

## Best Practices

### Scanning Guidelines:
1. **Get authorization** before scanning
2. **Schedule scans** during maintenance windows
3. **Start with** unauthenticated scans
4. **Validate findings** to reduce false positives
5. **Prioritize** based on risk and exploitability
6. **Track remediation** progress
7. **Rescan** after remediation

### Risk Prioritization:
- CVSS score
- Asset criticality
- Exploit availability
- Business impact
- Exposure level
- Compensating controls

## Conclusion
This workshop covered:
- Vulnerability scanning tools and techniques
- Custom vulnerability detection
- Automated scanning workflows
- Vulnerability management
- Remediation strategies

Effective vulnerability management requires continuous scanning, analysis, and remediation.

## Additional Resources
- NIST Vulnerability Management Guide
- CIS Controls
- OWASP Testing Guide
- CVE Database 